<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>全端開發人員天梯</title>
        <link>https://fullstackladder.dev/</link>
        <description>軟體開發學不完，就像爬不完的天梯，只好多紀錄寫筆記</description>
        <lastBuildDate>Sun, 07 Nov 2021 09:49:32 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh</language>
        <copyright>All rights reserved 2021, Mike Huang</copyright>
        <item>
            <title><![CDATA[使用 HttpContext 傳遞資料給 HttpInterceptor]]></title>
            <link>https://fullstackladder.dev/blog/2021/11/07/using-http-context-passing-data-to-http-interceptor</link>
            <guid>https://fullstackladder.dev/blog/2021/11/07/using-http-context-passing-data-to-http-interceptor</guid>
            <pubDate>Sun, 07 Nov 2021 15:00:00 GMT</pubDate>
            <description><![CDATA[<p>Angular 中的 HttpInterceptor 可以幫助我們攔截每個 HttpClient 送出的呼叫，幫助我們在呼叫前後打點各種大小事情，不過有時候我們反而希望 HttpInterctptor 不要自作主張幫我們處理太多事情，之前有些過一篇文章介紹<a href="https://fullstackladder.dev/blog/2019/01/06/mastering-angular-31-how-to-create-new-http-client-and-ignore-http-interceptors/">如何忽略 HTTP_INTERCEPTORS</a>，而到了 Angular 12 之後，則內建了 <a href="https://angular.io/api/common/http/HttpContext">HttpContext</a> 的功能，方便在程式中主動傳遞一些資料給我們自己設計的 HttpInterctptor，來達到一些更細緻的操作，這篇文章就來看一下 HttpContext 該如何使用。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[GitHub Actions] 印出事件相關資訊]]></title>
            <link>https://fullstackladder.dev/blog/2021/11/01/github-actions-print-events</link>
            <guid>https://fullstackladder.dev/blog/2021/11/01/github-actions-print-events</guid>
            <pubDate>Mon, 01 Nov 2021 16:37:00 GMT</pubDate>
            <description><![CDATA[<p>當使用 GitHub Actions 時，經常要針對來源事件去進行一些額外處理，導致要去查詢事件相關屬性，非常不方便，可以使用 [Debug action] 將相關資料印出，方便查找。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[GitHub Actions] 發送 Telegram 訊息]]></title>
            <link>https://fullstackladder.dev/blog/2021/11/01/github-actions-send-telegram</link>
            <guid>https://fullstackladder.dev/blog/2021/11/01/github-actions-send-telegram</guid>
            <pubDate>Mon, 01 Nov 2021 16:27:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[[GitHub Actions] 自動關閉某個 bot 的 issues]]></title>
            <link>https://fullstackladder.dev/blog/2021/11/01/github-actions-auto-close-bot-issue</link>
            <guid>https://fullstackladder.dev/blog/2021/11/01/github-actions-auto-close-bot-issue</guid>
            <pubDate>Mon, 01 Nov 2021 15:02:02 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[[Angular Universal] 使用 TransferState 解決畫面閃爍問題]]></title>
            <link>https://fullstackladder.dev/blog/2021/10/31/angular-universal-transfer-state</link>
            <guid>https://fullstackladder.dev/blog/2021/10/31/angular-universal-transfer-state</guid>
            <pubDate>Sun, 31 Oct 2021 15:00:00 GMT</pubDate>
            <description><![CDATA[<p>透過 Angular Universal 可以輕易達成 SSR 伺服器端渲染的效果，不過對於伺服器端產生的內容，到了 client 依然會重新進行產生，對於比較複雜的非同步處理如 HTTP 呼叫，就會發生重複呼叫，甚至造成畫面閃爍的問題。</p>
<p>針對這個問題，Angular 提出了 Transfer State (狀態轉移) 的做法，將 server 抓取資料的狀態移轉到 client，讓 client 可以直接使用這些狀態資料，而不是重新產生，以避免畫面閃爍等問題。</p>
<p>今天就來看看 Transfer State 的使用方式吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[透過 CLI Builder API 加強 Angular CLI 功能]]></title>
            <link>https://fullstackladder.dev/blog/2021/10/23/learn-angular-cli-builders</link>
            <guid>https://fullstackladder.dev/blog/2021/10/23/learn-angular-cli-builders</guid>
            <pubDate>Sat, 23 Oct 2021 12:12:56 GMT</pubDate>
            <description><![CDATA[<p>Angular CLI 可以幫助我們透過 <code>ng</code> 指令完成許多繁雜的工作，像是啟動開發用的伺服器 (<code>ng serve</code>)、將 Angular 專案建置成純前端網站 (<code>ng build</code>) 、或是進行單元測試 (<code>ng test</code>) 等等，這些指令其實背後都是一段又一段的程式，再搭配 Angular 的 CLI Builder API 整合起來的，而透過 CLI Builder API 也可以幫助我們將一些專案內經常運行的程式也整合到 Angular CLI 內，甚至可以藉此擴充原本內建的 Angular CLI 指令，今天就來看一下如何使用 CLI Builder API 吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[Angular Universal] 使用 Prerender 建立自己的 Static Site Generator]]></title>
            <link>https://fullstackladder.dev/blog/2021/10/16/static-site-generator-using-angular-universal-prerender</link>
            <guid>https://fullstackladder.dev/blog/2021/10/16/static-site-generator-using-angular-universal-prerender</guid>
            <pubDate>Sat, 16 Oct 2021 13:32:39 GMT</pubDate>
            <description><![CDATA[<p>隨著 Angular 不斷的改版，原來難用且功能差強人意的 <a href="https://angular.io/guide/universal">Angular Universal</a> 在不知不覺已經變得相當完整及強大，搭配 <a href="https://angular.io/guide/prerendering">Prerender</a> 功能，不用再依靠如 Hexo、Scully 等工具，要刻出屬於自己的 Static Site Generator (靜態網站產生器) 也變得相當容易，今天就來簡單看一下 Angular Universal 現在變得多麼簡單，且透過 Prerender 功能來打造一個簡單的 Static Site Generator 吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[Ramda] 使用 sortWith 輕鬆達成多欄位排序條件]]></title>
            <link>https://fullstackladder.dev/blog/2021/10/10/ramda-multiple-sort-using-sort-with</link>
            <guid>https://fullstackladder.dev/blog/2021/10/10/ramda-multiple-sort-using-sort-with</guid>
            <pubDate>Sun, 10 Oct 2021 12:21:01 GMT</pubDate>
            <description><![CDATA[<p>多欄位排序是一件不太困難，但也有點麻煩的事情，雖然 JavaScript 本身提供的 <code>sort()</code> 就可以達到目標，但寫起來就是醜醜的，而透過 Ramda 的 <code>sortWith()</code> 就簡單得多，而且更加好閱讀，今天就來如何使用 <code>sortWith()</code> 打造更好閱讀的排序程式。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[Luxon] 顯示 UTC 時間而非當地時間]]></title>
            <link>https://fullstackladder.dev/blog/2021/07/10/luxon-display-format-with-utc</link>
            <guid>https://fullstackladder.dev/blog/2021/07/10/luxon-display-format-with-utc</guid>
            <pubDate>Sat, 10 Jul 2021 19:33:07 GMT</pubDate>
            <description><![CDATA[<p><a href="https://moment.github.io/luxon">Luxon</a> 是一套輕巧但強大的時間處理 library，可以幫助我們快速解析來源時間字串，並處理好時區問題，不過預設處理時區有時候也會帶來一些困擾，今天就筆記一下如何用 Luxon 來處理各種時區問題。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[Angular 大師之路] Angular 12 預設開啟 strict mode 的生存之道]]></title>
            <link>https://fullstackladder.dev/blog/2021/06/21/how-to-survive-in-angular-12-strict-mode-using-async-pipe</link>
            <guid>https://fullstackladder.dev/blog/2021/06/21/how-to-survive-in-angular-12-strict-mode-using-async-pipe</guid>
            <pubDate>Mon, 21 Jun 2021 08:44:59 GMT</pubDate>
            <description><![CDATA[<p>Angular 12 預設在建立專案時，現在預設會開啟 <a href="https://angular.io/guide/strict-mode">strict mode</a> 了，strict mode 會加上一些 TypeScript team 建議的檢查，以及 Angular 額外加入的檢查；這代表在不改變設定的情況下，撰寫 Angular 程式將會需要花費更多的心力去處理各種型別的宣告，以避免在 compile 階段發生錯誤。</p>
<p>雖然感覺起來會越來越難寫，但往好處想，這些 strict mode 的檢查，都是為了減少程式在執行階段可能會發生的錯誤，減少非預期錯誤的可能性，也會減少許多 bug 發生的機會，讓我們寫出品質更好的程式碼，也省去更多 debug 的時間浪費！因此花些時間投資在寫出通過 strict mode 檢查的程式碼我覺得是很值得的，今天就來說幾個 strict mode 下容易發生的錯誤以及生存方法。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[C#] Rx.NET 筆記 (不定時更新)]]></title>
            <link>https://fullstackladder.dev/blog/2021/04/17/notes-for-rx-net</link>
            <guid>https://fullstackladder.dev/blog/2021/04/17/notes-for-rx-net</guid>
            <pubDate>Sat, 17 Apr 2021 09:47:02 GMT</pubDate>
            <description><![CDATA[<p>最近在專案中開始使用 <a href="http://Rx.NET">Rx.NET</a> 了，剛開始有些不太適應，不過大致熟悉後，寫起來還是很過癮，不輸給使用 RxJS，以下做一些簡單的筆記，讓對 <a href="http://Rx.NET">Rx.NET</a> 有興趣的朋友能快速上手。</p>
<p>因為之前都是寫 RxJS 居多，也會有一些跟 RxJS 的比較，不過主軸還是以 <a href="http://Rx.NET">Rx.NET</a> 為主。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 如何替 RxJS 撰寫測試 - 一般測試與彈珠圖測試方法]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/20/mastering-rxjs-35-how-to-test-rxjs-with-marble-diagrams</link>
            <guid>https://fullstackladder.dev/blog/2020/10/20/mastering-rxjs-35-how-to-test-rxjs-with-marble-diagrams</guid>
            <pubDate>Tue, 20 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天我們來聊聊如何撰寫測試程式來確保寫出來的 RxJS 如我們所想的一般運作，也就是撰寫測試程式碼！撰寫測試程式是軟體開發中非常重要的一環，雖然不是所有程式碼都一定要有對應的測試程式，但良好的測試程式卻可以幫助我們撰寫住更加穩固的程式碼。</p>
<p>至於到底該怎麼測試 RxJS？撰寫 RxJS 測試程式時又有什麼需要注意的呢？就讓我們繼續看下去吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 認識 Scheduler]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/19/mastering-rxjs-34-introduce-scheduler-of-rxjs</link>
            <guid>https://fullstackladder.dev/blog/2020/10/19/mastering-rxjs-34-introduce-scheduler-of-rxjs</guid>
            <pubDate>Mon, 19 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天我們來認識一下 RxJS 的 Scheduler，雖然在一般使用 RxJS 開發應用程式時幾乎不會用到 Scheduler，但 Scheduler 可以說是控制 RxJS 至關重要的角色，偶爾也有可能會需要使用 Scheduler 來調整事件發生時機！</p>
<p>到底什麼是 Scheduler？就讓我們繼續看下去吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 如何設計自己的 RxJS Operators]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/18/mastering-rxjs-33-how-to-customize-operators</link>
            <guid>https://fullstackladder.dev/blog/2020/10/18/mastering-rxjs-33-how-to-customize-operators</guid>
            <pubDate>Sun, 18 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天我們來聊點輕鬆(?)的主題 - 「如何設計出自己的 RxJS Operators」吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 實戰練習 - 使用 RxJS 實作 Flux Pattern]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/17/mastering-rxjs-32-implement-flux-pattern-with-rxjs</link>
            <guid>https://fullstackladder.dev/blog/2020/10/17/mastering-rxjs-32-implement-flux-pattern-with-rxjs</guid>
            <pubDate>Sat, 17 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>使用 React 作為前端架構的朋友對於 Flux 應該都不陌生，React 也內建了 Flux 讓我們可以直接使用，同時也有許多其他的 library 以這個架構為基礎設計，並應用在各種前端框架下，如 <a href="https://redux.js.org/">Redux</a> (for React)、<a href="https://ngrx.io/">NgRx</a> (for Angular) 和 <a href="https://vuex.vuejs.org/">Vuex</a> (for Vue) 等等。可以見得它是多麽重要的東西，今天我們來嘗試實際使用 RxJS 來實作一下這種架構，也藉此多認識一下 Flux Pattern 的重要觀念。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 實戰練習 - 自動完成 / 搜尋 / 排序 / 分頁]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/16/mastering-rxjs-31-practicing-autocomplete-search-sort-pagination</link>
            <guid>https://fullstackladder.dev/blog/2020/10/16/mastering-rxjs-31-practicing-autocomplete-search-sort-pagination</guid>
            <pubDate>Fri, 16 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天我們用實際的例子來練習各種 RxJS operators 的組合運用！在一般的應用程式裡面，資料查詢應該算是非常常見的情境了，我們就實際使用資料查詢的功能做範例，加上各種變化，來練習一些 operators 的實際使用吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] Multicast 類 Operator (1) - multicast / publish / refCount / share / shareReplay]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/15/mastering-rxjs-30-multicast-publish-refcount-share-sharereplay</link>
            <guid>https://fullstackladder.dev/blog/2020/10/15/mastering-rxjs-30-multicast-publish-refcount-share-sharereplay</guid>
            <pubDate>Thu, 15 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>還記得之前我們介紹過 Cold Observable v.s. Hot Observable 嗎？</p>
<p>Cold Observable 和觀察者 (Observer) 是一對一的關係，也就是每次產生訂閱時，都會是一個全新的資料流。而 Hot Observable 和觀察者則是一對多的關係，也就是每次產生訂閱時，都會使用「同一份資料流」，而今天要介紹的 operators 目的就是將 Cold Observable 轉成 Hot Observable，讓原來的資料流可以共用。</p>
<p>今天的觀念會比較複雜一點，打起精神繼續看下去吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 錯誤處理 Operators (1) - catchError / finalize / retry / retryWhen]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/14/mastering-rxjs-29-catcherror-finalize-retry-retrywhen</link>
            <guid>https://fullstackladder.dev/blog/2020/10/14/mastering-rxjs-29-catcherror-finalize-retry-retrywhen</guid>
            <pubDate>Wed, 14 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天來介紹一些跟「錯誤處理」有關的 operators。在使用 RxJS 時，資料流是透過 <code>pipe</code> 及各式各樣的 <code>operators</code> 在處理，且很多時候是非同步的，因此大多時候發生錯誤並不能單純的使用 <code>try...catch</code> 方式處理，就需要透過這些錯誤處理相關的 operators 來幫忙囉！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 工具類型 Operators (1) - tap / toArray / delay / delayWhen]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/13/mastering-rxjs-28-tap-toarray-delay-delaywhen</link>
            <guid>https://fullstackladder.dev/blog/2020/10/13/mastering-rxjs-28-tap-toarray-delay-delaywhen</guid>
            <pubDate>Tue, 13 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天要介紹的是「工具類型」的 Operators，也都不太困難，很好理解，繼續輕鬆學習吧！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[[RxJS] 數學/聚合類型 Operators (1) - min / max / count / reduce]]></title>
            <link>https://fullstackladder.dev/blog/2020/10/12/mastering-rxjs-27-min-max-count-reduce</link>
            <guid>https://fullstackladder.dev/blog/2020/10/12/mastering-rxjs-27-min-max-count-reduce</guid>
            <pubDate>Mon, 12 Oct 2020 18:00:00 GMT</pubDate>
            <description><![CDATA[<p>今天要介紹「數學/聚合類型」的 operators，這些 operators 會把來源 Observable 當作一個單純的資料列，取得一些基本的資訊，也可以自訂如何判斷資訊；這些 operators 都非常直覺好懂，就讓我們輕鬆來學習吧！</p>
]]></description>
        </item>
    </channel>
</rss>